{
  "Variable (let)": {
    "prefix": "let",
    "body": "let ${1:name} = ${2:value}",
    "description": "Declare a variable with let"
  },
  "Constant (const)": {
    "prefix": "const",
    "body": "const ${1:NAME} = ${2:value}",
    "description": "Declare a constant"
  },

  "Function (fn)": {
    "prefix": "fn",
    "body": [
      "fn ${1:name}(${2:args}) {",
      "    ${3:// body}",
      "    return ${4:value}",
      "}"
    ],
    "description": "Quantum fn function"
  },
  "Function (def)": {
    "prefix": "def",
    "body": [
      "def ${1:name}(${2:args}):",
      "    ${3:# body}",
      "    return ${4:value}"
    ],
    "description": "Python-style def function"
  },
  "Function (function)": {
    "prefix": "function",
    "body": [
      "function ${1:name}(${2:args}) {",
      "    ${3:// body}",
      "    return ${4:value}",
      "}"
    ],
    "description": "JavaScript-style function"
  },
  "Arrow Function": {
    "prefix": "arrow",
    "body": "const ${1:name} = (${2:args}) => ${3:expression}",
    "description": "Arrow function (expression)"
  },
  "Arrow Function (block)": {
    "prefix": "arrowfn",
    "body": [
      "const ${1:name} = (${2:args}) => {",
      "    ${3:// body}",
      "    return ${4:value}",
      "}"
    ],
    "description": "Arrow function with block body"
  },
  "Anonymous Function": {
    "prefix": "anon",
    "body": "fn(${1:args}) { return ${2:value} }",
    "description": "Anonymous function"
  },

  "If Statement": {
    "prefix": "if",
    "body": [
      "if ${1:condition} {",
      "    ${2:// code}",
      "}"
    ],
    "description": "If statement (brace style)"
  },
  "If Statement (Python)": {
    "prefix": "ifp",
    "body": [
      "if ${1:condition}:",
      "    ${2:pass}"
    ],
    "description": "If statement (Python style)"
  },
  "If-Else": {
    "prefix": "ifelse",
    "body": [
      "if ${1:condition} {",
      "    ${2:// if body}",
      "} else {",
      "    ${3:// else body}",
      "}"
    ],
    "description": "If-else statement"
  },
  "If-Elif-Else (Python)": {
    "prefix": "ifelifelse",
    "body": [
      "if ${1:condition}:",
      "    ${2:pass}",
      "elif ${3:condition}:",
      "    ${4:pass}",
      "else:",
      "    ${5:pass}"
    ],
    "description": "Full if-elif-else (Python style)"
  },
  "Ternary (inline)": {
    "prefix": "tern",
    "body": "${1:condition} ? ${2:true_val} : ${3:false_val}",
    "description": "Ternary expression"
  },

  "While Loop": {
    "prefix": "while",
    "body": [
      "while ${1:condition} {",
      "    ${2:// body}",
      "}"
    ],
    "description": "While loop (brace style)"
  },
  "While Loop (Python)": {
    "prefix": "whilep",
    "body": [
      "while ${1:condition}:",
      "    ${2:pass}"
    ],
    "description": "While loop (Python style)"
  },
  "For-in Loop": {
    "prefix": "for",
    "body": [
      "for ${1:item} in ${2:collection} {",
      "    ${3:// body}",
      "}"
    ],
    "description": "For-in loop"
  },
  "For-in Loop (Python)": {
    "prefix": "forp",
    "body": [
      "for ${1:item} in ${2:collection}:",
      "    ${3:pass}"
    ],
    "description": "For-in loop (Python style)"
  },
  "For Range": {
    "prefix": "forrange",
    "body": [
      "for ${1:i} in range(${2:10}):",
      "    ${3:pass}"
    ],
    "description": "Range-based for loop"
  },
  "For Range (start, end)": {
    "prefix": "forrange2",
    "body": [
      "for ${1:i} in range(${2:1}, ${3:11}):",
      "    ${4:pass}"
    ],
    "description": "Range-based for loop with start and end"
  },

  "Print": {
    "prefix": "print",
    "body": "print(${1:value})",
    "description": "Print statement"
  },
  "Printf": {
    "prefix": "printf",
    "body": "printf(\"${1:%s}\\n\", ${2:value})",
    "description": "C-style printf"
  },
  "Cout": {
    "prefix": "cout",
    "body": "cout << ${1:value} << endl",
    "description": "C++ cout output"
  },
  "Scanf": {
    "prefix": "scanf",
    "body": "scanf(\"${1:%d}\", &${2:var})",
    "description": "C-style scanf input"
  },
  "Cin": {
    "prefix": "cin",
    "body": "cin >> ${1:var}",
    "description": "C++ cin input"
  },

  "Array": {
    "prefix": "array",
    "body": "let ${1:arr} = [${2:items}]",
    "description": "Create an array"
  },
  "Array Map": {
    "prefix": "map",
    "body": "${1:arr}.map(${2:x} => ${3:x * 2})",
    "description": "Array map"
  },
  "Array Filter": {
    "prefix": "filter",
    "body": "${1:arr}.filter(${2:x} => ${3:x > 0})",
    "description": "Array filter"
  },
  "Array Reduce": {
    "prefix": "reduce",
    "body": "${1:arr}.reduce((${2:acc}, ${3:x}) => ${4:acc + x}, ${5:0})",
    "description": "Array reduce"
  },
  "Array Push": {
    "prefix": "push",
    "body": "${1:arr}.push(${2:value})",
    "description": "Push to array"
  },
  "Array Sort": {
    "prefix": "sort",
    "body": "${1:arr}.sort()",
    "description": "Sort array"
  },

  "Dictionary": {
    "prefix": "dict",
    "body": [
      "let ${1:d} = {",
      "    \"${2:key}\": ${3:value}",
      "}"
    ],
    "description": "Create a dictionary"
  },
  "Dict Keys": {
    "prefix": "dkeys",
    "body": "${1:d}.keys()",
    "description": "Get dictionary keys"
  },
  "Dict Values": {
    "prefix": "dvals",
    "body": "${1:d}.values()",
    "description": "Get dictionary values"
  },

  "Class": {
    "prefix": "class",
    "body": [
      "class ${1:ClassName} {",
      "    fn init(${2:args}) {",
      "        self.${3:field} = ${4:value}",
      "    }",
      "",
      "    fn ${5:method}() {",
      "        return ${6:null}",
      "    }",
      "}"
    ],
    "description": "Class definition"
  },
  "Class with Inheritance": {
    "prefix": "classext",
    "body": [
      "class ${1:ChildClass} extends ${2:ParentClass} {",
      "    fn init(${3:args}) {",
      "        self.${4:field} = ${5:value}",
      "    }",
      "",
      "    fn ${6:method}() {",
      "        return ${7:null}",
      "    }",
      "}"
    ],
    "description": "Class with inheritance"
  },

  "Closure / Counter": {
    "prefix": "closure",
    "body": [
      "fn ${1:make_counter}(${2:start}) {",
      "    ${3:count} = ${2:start}",
      "    return fn() {",
      "        ${3:count} += 1",
      "        return ${3:count}",
      "    }",
      "}",
      "",
      "let ${4:counter} = ${1:make_counter}(0)"
    ],
    "description": "Closure pattern (counter example)"
  },

  "XOR Encrypt": {
    "prefix": "xor",
    "body": [
      "fn xor_encrypt(text, key) {",
      "    return xor_bytes(text, key)",
      "}",
      "",
      "let ${1:message}   = \"${2:Hello, Quantum!}\"",
      "let ${3:key}       = \"${4:secret}\"",
      "let ${5:encrypted} = xor_encrypt(${1:message}, ${3:key})",
      "let ${6:decrypted} = xor_encrypt(${5:encrypted}, ${3:key})",
      "",
      "print(\"Encrypted:\", to_hex(${5:encrypted}))",
      "print(\"Decrypted:\", ${6:decrypted})"
    ],
    "description": "XOR encryption/decryption template"
  },
  "Base64 Encode": {
    "prefix": "b64",
    "body": [
      "let ${1:encoded} = base64_encode(${2:\"Hello, World!\"})",
      "print(\"Base64:\", ${1:encoded})"
    ],
    "description": "Base64 encoding"
  },
  "Hex Dump": {
    "prefix": "hexdump",
    "body": [
      "let ${1:data} = \"${2:Hello}\"",
      "print(\"Hex:\", to_hex(${1:data}))",
      "print(\"Bin:\", bin(${3:255}))"
    ],
    "description": "Hex dump template"
  },
  "Hash (reserved)": {
    "prefix": "hashfn",
    "body": [
      "# TODO: hash module coming in v2.0",
      "# hash.sha256(\"${1:data}\")",
      "# hash.md5(\"${1:data}\")"
    ],
    "description": "Hash placeholder (reserved keyword)"
  },

  "Fibonacci (recursive)": {
    "prefix": "fib",
    "body": [
      "def fib(n):",
      "    if n <= 1:",
      "        return n",
      "    return fib(n - 1) + fib(n - 2)",
      "",
      "for i in range(${1:10}):",
      "    print(fib(i))"
    ],
    "description": "Fibonacci sequence (Python style)"
  },
  "FizzBuzz": {
    "prefix": "fizzbuzz",
    "body": [
      "for ${1:i} in range(1, ${2:31}):",
      "    if ${1:i} % 15 == 0:",
      "        print(\"FizzBuzz\")",
      "    elif ${1:i} % 3 == 0:",
      "        print(\"Fizz\")",
      "    elif ${1:i} % 5 == 0:",
      "        print(\"Buzz\")",
      "    else:",
      "        print(${1:i})"
    ],
    "description": "FizzBuzz"
  },
  "Higher-Order Functions": {
    "prefix": "hof",
    "body": [
      "let ${1:numbers} = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]",
      "",
      "let evens   = ${1:numbers}.filter(x => x % 2 == 0)",
      "let squares = evens.map(x => x * x)",
      "let total   = squares.reduce((acc, x) => acc + x, 0)",
      "",
      "print(\"Total:\", total)"
    ],
    "description": "Filter → Map → Reduce pipeline"
  },
  "Bitwise Ops": {
    "prefix": "bitwise",
    "body": [
      "let a = ${1:0xFF}",
      "let b = ${2:0x0F}",
      "",
      "print(\"AND:\",  a & b)",
      "print(\"OR: \",  a | b)",
      "print(\"XOR:\",  a ^ b)",
      "print(\"NOT:\",  ~a)",
      "print(\"SHL:\",  1 << ${3:8})",
      "print(\"SHR:\",  ${4:256} >> ${5:4})",
      "print(\"Hex:\",  hex(a & b))"
    ],
    "description": "Bitwise operations demo"
  },

  "Multiline Python Tag": {
    "prefix": "tagpy",
    "body": "${1:code}  #Python",
    "description": "Tag this line as Python syntax"
  },
  "Multiline C Tag": {
    "prefix": "tagc",
    "body": "${1:code}  #C",
    "description": "Tag this line as C syntax"
  },
  "Multiline C++ Tag": {
    "prefix": "tagcpp",
    "body": "${1:code}  #C++",
    "description": "Tag this line as C++ syntax"
  },
  "Multiline JS Tag": {
    "prefix": "tagjs",
    "body": "${1:code}  #JS",
    "description": "Tag this line as JavaScript syntax"
  },

  "Region Fold": {
    "prefix": "region",
    "body": [
      "# region ${1:Section Name}",
      "${2:// code}",
      "# endregion"
    ],
    "description": "Foldable code region"
  },
  "Assert": {
    "prefix": "assert",
    "body": "assert(${1:condition}, \"${2:Error message}\")",
    "description": "Assert with message"
  },
  "Sleep": {
    "prefix": "sleep",
    "body": "sleep(${1:1})",
    "description": "Sleep for N seconds"
  },
  "Format String": {
    "prefix": "fmt",
    "body": "format(\"${1:%s} = ${2:%d}\", ${3:name}, ${4:value})",
    "description": "Format string"
  }
}
