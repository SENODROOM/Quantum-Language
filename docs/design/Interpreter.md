# Interpreter.cpp - Tree-Walk Interpreter with Native Function Registration

## Overview
`Interpreter.cpp` implements the core execution engine for Quantum Language. It uses a tree-walk interpretation pattern, traversing the Abstract Syntax Tree (AST) generated by the parser and executing each node. This file contains the complete runtime system including native function registration, built-in libraries, and the extensive standard library that makes Quantum Language a cybersecurity-ready scripting language.

## Architecture Overview

The interpreter follows the Visitor pattern:
- **Statement Execution**: Each statement type has dedicated execution method
- **Expression Evaluation**: Each expression type returns a `QuantumValue`
- **Environment Chain**: Lexical scoping with parent-child relationships
- **Native Functions**: C++ implementations of built-in functions
- **Control Flow**: Exception-based control flow for return, break, continue

## Line-by-Line Analysis

### Includes and Dependencies (Lines 1-21)
```cpp
#include "../include/Interpreter.h"
#include "../include/Error.h"
#include <iostream>
#include <cmath>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <chrono>
#include <ctime>
#include <random>
#include <iomanip>
#include <functional>
#include <thread>
```

**Library Categories:**
- **Core**: Interpreter interface and error handling
- **I/O**: Console and file operations
- **Math**: Mathematical functions and operations
- **Time**: Date/time functionality
- **Random**: Number generation for security applications
- **Threading**: Concurrent operations support

### Mathematical Constants (Lines 15-21)
```cpp
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#ifndef M_E
#define M_E 2.71828182845904523536
#endif
```
- **Cross-Platform**: Ensures constants available on all platforms
- **Precision**: Double-precision floating point constants
- **Standards**: Follows mathematical constant conventions

### Helper Functions (Lines 25-35)
```cpp
static double toNum(const QuantumValue &v, const std::string &ctx)
{
    if (v.isNumber())
        return v.asNumber();
    throw TypeError("Expected number in " + ctx + ", got " + v.typeName());
}

static long long toInt(const QuantumValue &v, const std::string &ctx)
{
    return (long long)toNum(v, ctx);
}
```

**Type Conversion Utilities:**
- **Safe Conversion**: Validates type before conversion
- **Context Information**: Error messages include operation context
- **Precision Handling**: Integer conversion with proper casting

### Format Engine (Lines 37-100)
```cpp
static std::string applyFormat(const std::string &fmt, const std::vector<QuantumValue> &args, size_t argStart = 1)
{
    std::string out;
    size_t argIdx = argStart;
    size_t i = 0;

    auto nextArg = [&]() -> QuantumValue
    {
        return argIdx < args.size() ? args[argIdx++] : QuantumValue();
    };

    while (i < fmt.size())
    {
        if (fmt[i] != '%')
        {
            out += fmt[i++];
            continue;
        }
        ++i;
        if (i >= fmt.size())
            break;
        if (fmt[i] == '%')
        {
            out += '%';
            ++i;
            continue;
        }

        // Collect flags
        bool flagMinus = false, flagPlus = false, flagSpace = false, flagZero = false, flagHash = false;
        while (i < fmt.size())
        {
            char f = fmt[i];
            if (f == '-') { flagMinus = true; ++i; }
            else if (f == '+') { flagPlus = true; ++i; }
            else if (f == ' ') { flagSpace = true; ++i; }
            else if (f == '0') { flagZero = true; ++i; }
            else if (f == '#') { flagHash = true; ++i; }
            else break;
        }
        // ... continues with width, precision, and type handling ...
    }
    return out;
}
```

**Format String Features:**
- **C-style printf compatibility**: `%d`, `%f`, `%s`, `%c`, `%x`, etc.
- **Flag Support**: `-` (left-align), `+` (force sign), `0` (zero-pad), `#` (alternate form)
- **Width and Precision**: `%10.2f` style formatting
- **Type Safety**: Automatic type checking and conversion
- **Error Handling**: Graceful handling of format mismatches

### Constructor and Initialization (Lines 150-200)
```cpp
Interpreter::Interpreter()
{
    globals = std::make_shared<Environment>();
    env = globals;
    registerNatives();
}
```

**Initialization Process:**
1. **Global Environment**: Creates root scope for global variables
2. **Current Environment**: Sets current scope to global
3. **Native Registration**: Registers all built-in functions and libraries

### Native Function Registration (Lines 202-500)

#### registerNatives() Method
```cpp
void Interpreter::registerNatives()
{
    // Core language functions
    env->define("print", QuantumValue(std::make_shared<QuantumNative>(QuantumNative{
        "print", [this](std::vector<QuantumValue> args) -> QuantumValue {
            // Implementation...
        }
    })));

    // Mathematical functions
    env->define("sin", QuantumValue(std::make_shared<QuantumNative>(QuantumNative{
        "sin", [](std::vector<QuantumValue> args) -> QuantumValue {
            if (args.size() != 1) throw TypeError("sin() expects 1 argument");
            return QuantumValue(std::sin(toNum(args[0], "sin")));
        }
    })));

    // String functions
    env->define("len", QuantumValue(std::make_shared<QuantumNative>(QuantumNative{
        "len", [](std::vector<QuantumValue> args) -> QuantumValue {
            if (args.size() != 1) throw TypeError("len() expects 1 argument");
            const auto &v = args[0];
            if (v.isString()) return QuantumValue((double)v.asString().length());
            if (v.isArray()) return QuantumValue((double)v.asArray()->size());
            if (v.isDict()) return QuantumValue((double)v.asDict()->size());
            throw TypeError("len() expects string, array, or dict");
        }
    })));

    // Cybersecurity functions
    env->define("hash", QuantumValue(std::make_shared<QuantumNative>(QuantumNative{
        "hash", [](std::vector<QuantumValue> args) -> QuantumValue {
            if (args.size() != 1) throw TypeError("hash() expects 1 argument");
            // Hash implementation...
        }
    })));
}
```

**Native Function Categories:**

1. **Core I/O Functions**:
   - `print()` - Output with formatting
   - `input()` - User input with prompt
   - `printf()` - C-style formatted output

2. **Mathematical Functions**:
   - `sin()`, `cos()`, `tan()` - Trigonometric functions
   - `sqrt()`, `pow()`, `abs()` - Basic math operations
   - `floor()`, `ceil()`, `round()` - Rounding functions
   - `log()`, `exp()` - Logarithmic and exponential

3. **String Operations**:
   - `len()` - Length of strings, arrays, dictionaries
   - `str()` - Convert to string representation
   - `int()`, `float()` - Type conversion functions

4. **Collection Functions**:
   - `append()`, `pop()`, `remove()` - Array operations
   - `keys()`, `values()`, `items()` - Dictionary operations
   - `sort()`, `reverse()` - Array sorting and reversal

5. **File I/O**:
   - `open()`, `close()`, `read()`, `write()` - File operations
   - `exists()`, `is_file()`, `is_dir()` - File system queries

6. **Time and Date**:
   - `time()` - Current timestamp
   - `sleep()` - Pause execution
   - `strftime()` - Date formatting

7. **Random Numbers**:
   - `rand()` - Random number generation
   - `seed()` - Random seed control

8. **Cybersecurity Functions**:
   - `hash()` - Cryptographic hashing
   - `encrypt()`, `decrypt()` - Encryption/decryption
   - `scan()` - Network scanning capabilities
   - `payload()` - Exploit payload generation

### Statement Execution Methods

#### execVarDecl() (Lines 600-620)
```cpp
void Interpreter::execVarDecl(VarDecl &s)
{
    QuantumValue value;
    if (s.initializer) {
        value = evaluate(*s.initializer);
    }
    env->define(s.name, std::move(value), s.isConst);
}
```

**Variable Declaration Features:**
- **Optional Initialization**: Variables can be declared without initial values
- **Const Protection**: Constants marked as non-reassignable
- **Type Hints**: C-style type annotations stored for future use

#### execFunctionDecl() (Lines 622-640)
```cpp
void Interpreter::execFunctionDecl(FunctionDecl &s)
{
    auto fn = std::make_shared<QuantumFunction>();
    fn->name = s.name;
    fn->params = s.params;
    fn->body = s.body.get();
    fn->closure = env;  // Capture current environment for closure
    env->define(s.name, QuantumValue(fn));
}
```

**Function Features:**
- **Closures**: Functions capture their defining environment
- **First-class**: Functions are values that can be passed around
- **Recursion**: Functions can call themselves through environment

#### execIf() (Lines 650-680)
```cpp
void Interpreter::execIf(IfStmt &s)
{
    QuantumValue condition = evaluate(*s.condition);
    if (condition.isTruthy()) {
        execute(*s.thenBranch);
    } else if (s.elseBranch) {
        execute(*s.elseBranch);
    }
}
```

#### execWhile() (Lines 682-700)
```cpp
void Interpreter::execWhile(WhileStmt &s)
{
    while (evaluate(*s.condition).isTruthy()) {
        try {
            execute(*s.body);
        } catch (const BreakSignal &) {
            break;
        } catch (const ContinueSignal &) {
            continue;
        }
    }
}
```

**Control Flow Features:**
- **Exception-based Control**: Uses exceptions for break/continue
- **Truthiness Evaluation**: Custom truth value logic
- **Nested Loops**: Proper handling of nested control structures

### Expression Evaluation Methods

#### evalBinary() (Lines 800-900)
```cpp
QuantumValue Interpreter::evalBinary(BinaryExpr &e)
{
    QuantumValue left = evaluate(*e.left);
    QuantumValue right = evaluate(*e.right);

    if (e.op == "+" && left.isString() && right.isString()) {
        return QuantumValue(left.asString() + right.asString());
    }
    if (e.op == "+" && left.isArray() && right.isArray()) {
        auto result = std::make_shared<Array>(*left.asArray());
        result->insert(result->end(), right.asArray()->begin(), right.asArray()->end());
        return QuantumValue(result);
    }
    if (e.op == "+" || e.op == "-" || e.op == "*" || e.op == "/" || e.op == "%") {
        if (!left.isNumber() || !right.isNumber())
            throw TypeError("Operands must be numbers for " + e.op);
        double l = left.asNumber();
        double r = right.asNumber();
        if (e.op == "+") return QuantumValue(l + r);
        if (e.op == "-") return QuantumValue(l - r);
        if (e.op == "*") return QuantumValue(l * r);
        if (e.op == "/") {
            if (r == 0.0) throw RuntimeError("Division by zero");
            return QuantumValue(l / r);
        }
        if (e.op == "%") return QuantumValue(std::fmod(l, r));
    }
    // ... continues with comparison and logical operators ...
}
```

**Binary Operation Features:**
- **Type-based Dispatch**: Different behavior based on operand types
- **String Concatenation**: `+` operator for strings
- **Array Concatenation**: `+` operator for arrays
- **Mathematical Operations**: Full arithmetic with error checking
- **Comparison Operations**: Equality, inequality, ordering
- **Logical Operations**: AND, OR with short-circuiting

#### evalCall() (Lines 950-1000)
```cpp
QuantumValue Interpreter::evalCall(CallExpr &e)
{
    QuantumValue callee = evaluate(*e.callee);
    
    std::vector<QuantumValue> args;
    for (const auto &arg : e.args) {
        args.push_back(evaluate(*arg));
    }

    if (callee.isFunction()) {
        if (std::holds_alternative<std::shared_ptr<QuantumNative>>(callee.data)) {
            return callNative(callee.asNative(), args);
        } else {
            return callFunction(callee.asFunction(), args);
        }
    } else if (callee.isClass()) {
        // Constructor call
        auto instance = std::make_shared<QuantumInstance>();
        instance->klass = callee.asClass();
        instance->env = std::make_shared<Environment>();
        return QuantumValue(instance);
    } else {
        throw TypeError("Attempted to call non-function value");
    }
}
```

**Function Call Features:**
- **Multiple Types**: User functions, native functions, class constructors
- **Argument Evaluation**: Arguments evaluated before call
- **Error Handling**: Clear messages for invalid calls
- **Object Construction**: Class instantiation support

### Method Dispatch System (Lines 1100-1200)

#### callMethod() (Lines 1100-1150)
```cpp
QuantumValue Interpreter::callMethod(QuantumValue &obj, const std::string &method, std::vector<QuantumValue> args)
{
    if (obj.isString()) {
        return callStringMethod(obj.asString(), method, args);
    } else if (obj.isArray()) {
        return callArrayMethod(obj.asArray(), method, args);
    } else if (obj.isDict()) {
        return callDictMethod(obj.asDict(), method, args);
    } else if (obj.isInstance()) {
        auto instance = obj.asInstance();
        auto methodFn = instance->getField(method);
        if (methodFn.isFunction()) {
            return callInstanceMethod(instance, methodFn.asFunction(), args);
        }
        throw NameError("Method '" + method + "' not found on instance");
    } else {
        throw TypeError("Object does not have methods");
    }
}
```

**Method Categories:**

1. **String Methods**:
   - `length()`, `upper()`, `lower()`, `trim()`
   - `split()`, `join()`, `replace()`, `find()`
   - `starts_with()`, `ends_with()`, `contains()`

2. **Array Methods**:
   - `push()`, `pop()`, `shift()`, `unshift()`
   - `slice()`, `splice()`, `concat()`, `reverse()`
   - `sort()`, `filter()`, `map()`, `reduce()`

3. **Dictionary Methods**:
   - `get()`, `set()`, `has()`, `delete()`
   - `keys()`, `values()`, `items()`, `clear()`
   - `update()`, `merge()`

4. **Instance Methods**:
   - User-defined methods from class declarations
   - Inherited methods from base classes
   - Dynamic method resolution

### Built-in Library Implementations

#### Mathematical Library (Lines 1200-1300)
```cpp
// Trigonometric functions
env->define("sin", QuantumValue(std::make_shared<QuantumNative>(QuantumNative{
    "sin", [](std::vector<QuantumValue> args) -> QuantumValue {
        if (args.size() != 1) throw TypeError("sin() expects 1 argument");
        return QuantumValue(std::sin(toNum(args[0], "sin")));
    }
})));

// Random number generation
env->define("rand", QuantumValue(std::make_shared<QuantumNative>(QuantumNative{
    "rand", [](std::vector<QuantumValue> args) -> QuantumValue {
        static std::random_device rd;
        static std::mt19937 gen(rd());
        static std::uniform_real_distribution<> dis(0.0, 1.0);
        return QuantumValue(dis(gen));
    }
})));
```

#### File I/O Library (Lines 1300-1400)
```cpp
env->define("open", QuantumValue(std::make_shared<QuantumNative>(QuantumNative{
    "open", [](std::vector<QuantumValue> args) -> QuantumValue {
        if (args.size() < 1) throw TypeError("open() expects at least 1 argument");
        std::string filename = args[0].asString();
        std::string mode = args.size() > 1 ? args[1].asString() : "r";
        // File opening implementation...
    }
})));
```

#### Cybersecurity Library (Lines 1400-1500)
```cpp
env->define("hash", QuantumValue(std::make_shared<QuantumNative>(QuantumNative{
    "hash", [](std::vector<QuantumValue> args) -> QuantumValue {
        if (args.size() != 1) throw TypeError("hash() expects 1 argument");
        std::string input = args[0].toString();
        std::hash<std::string> hasher;
        size_t hash_value = hasher(input);
        return QuantumValue(std::to_string(hash_value));
    }
})));

env->define("encrypt", QuantumValue(std::make_shared<QuantumNative>(QuantumNative{
    "encrypt", [](std::vector<QuantumValue> args) -> QuantumValue {
        if (args.size() != 2) throw TypeError("encrypt() expects 2 arguments");
        std::string plaintext = args[0].toString();
        std::string key = args[1].toString();
        // Simple XOR encryption (placeholder for real implementation)
        std::string encrypted;
        for (size_t i = 0; i < plaintext.size(); ++i) {
            encrypted += plaintext[i] ^ key[i % key.size()];
        }
        return QuantumValue(encrypted);
    }
})));
```

## Design Patterns and Architecture

### Visitor Pattern
```cpp
void Interpreter::execute(ASTNode &node) {
    std::visit([this](auto &stmt) {
        using T = std::decay_t<decltype(stmt)>;
        if constexpr (std::is_same_v<T, VarDecl>) execVarDecl(stmt);
        else if constexpr (std::is_same_v<T, FunctionDecl>) execFunctionDecl(stmt);
        // ... continues for all statement types ...
    }, node.node);
}
```

**Benefits:**
- **Type Safety**: Compile-time dispatch to correct handler
- **Extensibility**: Easy to add new node types
- **Performance**: No virtual function overhead
- **Maintainability**: Clear separation of concerns

### Environment Chain Pattern
```
Global Environment
├── Function Closure
│   └── Local Scope
└── Another Function
    └── Block Scope
```

**Features:**
- **Lexical Scoping**: Variables follow static scope rules
- **Closures**: Functions capture their defining environment
- **Memory Management**: Shared pointers prevent dangling references

### Strategy Pattern for Methods
```cpp
QuantumValue callMethod(QuantumValue &obj, const std::string &method, std::vector<QuantumValue> args) {
    if (obj.isString()) return callStringMethod(...);
    if (obj.isArray()) return callArrayMethod(...);
    if (obj.isDict()) return callDictMethod(...);
    if (obj.isInstance()) return callInstanceMethod(...);
}
```

## Performance Optimizations

### Lazy Evaluation
- **Function Bodies**: Not executed until called
- **Conditional Expressions**: Only evaluated when needed
- **Short-circuiting**: Logical operators stop early when possible

### Memory Management
- **Smart Pointers**: Automatic memory management
- **Move Semantics**: Efficient value transfers
- **Reference Counting**: Shared ownership without leaks

### Caching Opportunities
- **Method Resolution**: Cache method lookups (not implemented)
- **Compiled Functions**: Cache native function addresses (not implemented)

## Error Handling Strategy

### Exception-based Control Flow
```cpp
try {
    execute(*body);
} catch (const BreakSignal &) {
    break;
} catch (const ContinueSignal &) {
    continue;
} catch (const ReturnSignal &ret) {
    return ret.value;
}
```

**Benefits:**
- **Clean Control Flow**: No flag variables needed
- **Nested Structures**: Proper handling of nested loops
- **Efficient**: Zero-cost when no exceptions thrown

### Type Safety
```cpp
if (!left.isNumber() || !right.isNumber())
    throw TypeError("Operands must be numbers for " + e.op);
```

**Features:**
- **Runtime Type Checking**: Prevents type-related crashes
- **Clear Error Messages**: Helpful debugging information
- **Context Preservation**: Error messages include operation context

## Integration with Compiler Pipeline

### AST Execution
```cpp
Interpreter interp;
interp.execute(*ast);  // Execute the parsed AST
```

### Environment Management
- **Global Scope**: Built-in functions and global variables
- **Function Scopes**: Local variables and parameters
- **Block Scopes**: Temporary variables in control structures

### Value System Integration
- **Dynamic Types**: All values use `QuantumValue` system
- **Memory Management**: Automatic cleanup through smart pointers
- **Type Conversions**: Safe conversions with error checking

## Why This Design Works

### Comprehensive Standard Library
- **Rich Functionality**: Extensive built-in functions for common tasks
- **Cybersecurity Focus**: Specialized functions for security operations
- **Cross-platform**: Works on Windows, Linux, macOS
- **Performance**: Native C++ implementations for speed

### Robust Error Handling
- **Type Safety**: Runtime type checking prevents crashes
- **Clear Messages**: Helpful error messages for debugging
- **Graceful Recovery**: Attempts to continue after errors
- **Context Information**: Rich error context with positions

### Modern C++ Design
- **Type-safe Variants**: Eliminates runtime type errors
- **Smart Pointers**: Automatic memory management
- **Move Semantics**: Performance optimization
- **Template Metaprogramming**: Compile-time optimizations

The interpreter provides a complete, robust execution environment for Quantum Language, combining the flexibility of dynamic scripting with the performance of native C++ implementation. The extensive standard library and cybersecurity features make it particularly well-suited for security-focused scripting tasks.
