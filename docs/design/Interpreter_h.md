# Interpreter.h - Interpreter Class Interface and Execution Methods

## Overview
`Interpreter.h` defines the interface for the interpretation phase of the Quantum Language compiler. It declares the `Interpreter` class responsible for executing the Abstract Syntax Tree (AST) generated by the parser, implementing a tree-walk interpreter with comprehensive runtime support including native functions, object-oriented programming, and extensive built-in libraries.

## Architecture Overview

The interpreter interface provides:
- **AST Execution**: Main entry point for executing parsed programs
- **Statement Execution**: Methods for all statement types
- **Expression Evaluation**: Methods for all expression types
- **Runtime Environment**: Lexical scoping and variable management
- **Native Function Integration**: Bridge to C++ implementations
- **Object-Oriented Support**: Class and instance method dispatch

## Line-by-Line Analysis

### Header Guard and Dependencies (Lines 1-4)
```cpp
#pragma once
#include "AST.h"
#include "Value.h"
#include <memory>
```

**Dependency Analysis:**
- **`AST.h`**: AST node definitions for execution input
- **`Value.h`**: Value system and runtime types for execution output
- **`memory`**: Smart pointers for automatic memory management

### Interpreter Class Declaration (Lines 6-58)

#### Class Definition (Line 6)
```cpp
class Interpreter
{
```

**Class Design:**
- **Tree-walk Pattern**: Traverses AST to execute programs
- **Stateful Design**: Maintains environment chain for scoping
- **Visitor Pattern**: Different methods for different AST node types

#### Public Interface (Lines 8-14)
```cpp
public:
    Interpreter();
    void execute(ASTNode &node);
    QuantumValue evaluate(ASTNode &node);
    void execBlock(BlockStmt &s, std::shared_ptr<Environment> scope = nullptr);

    std::shared_ptr<Environment> globals;
```

**Public Methods Analysis:**

**Constructor (Line 9):**
```cpp
Interpreter();
```
- **Purpose**: Initializes interpreter with global environment
- **Setup**: Registers native functions and built-in libraries
- **Environment**: Creates global scope for program execution

**execute() Method (Line 10):**
```cpp
void execute(ASTNode &node);
```
- **Purpose**: Executes AST nodes that represent statements
- **Parameter**: Reference to AST node to execute
- **Side Effects**: May modify environment, produce output, etc.
- **Use Case**: Top-level program execution and statement execution

**evaluate() Method (Line 11):**
```cpp
QuantumValue evaluate(ASTNode &node);
```
- **Purpose**: Evaluates AST nodes that represent expressions
- **Parameter**: Reference to AST node to evaluate
- **Return Value**: Computed value of the expression
- **Use Case**: Expression evaluation in assignments, function calls, etc.

**execBlock() Method (Line 12):**
```cpp
void execBlock(BlockStmt &s, std::shared_ptr<Environment> scope = nullptr);
```
- **Purpose**: Executes blocks of statements with optional scope
- **Parameters**: 
  - `s`: Block statement containing multiple statements
  - `scope`: Optional environment for the block (creates new if null)
- **Use Case**: Function bodies, control flow blocks, class methods

**globals Member (Line 14):**
```cpp
std::shared_ptr<Environment> globals;
```
- **Purpose**: Global environment containing built-in functions and variables
- **Public Access**: Allows external access to global scope
- **Shared Ownership**: Multiple references possible (e.g., closures)

#### Private Members (Lines 16-58)

**Current Environment (Line 17):**
```cpp
private:
    std::shared_ptr<Environment> env;
```

**Environment Analysis:**
- **Current Scope**: Points to currently active environment
- **Chain Structure**: Part of environment chain for lexical scoping
- **Dynamic Changes**: Switches between scopes during execution

**Native Function Registration (Line 19):**
```cpp
    void registerNatives();
```

**Registration Features:**
- **Built-in Functions**: Registers all native C++ functions
- **Standard Library**: Sets up mathematical, I/O, and security functions
- **Global Scope**: Adds functions to global environment
- **Initialization**: Called during interpreter construction

**Statement Execution Methods (Lines 21-32):**
```cpp
    // Statement executors
    void execVarDecl(VarDecl &s);
    void execFunctionDecl(FunctionDecl &s);
    void execClassDecl(ClassDecl &s);
    void execIf(IfStmt &s);
    void execWhile(WhileStmt &s);
    void execFor(ForStmt &s);
    void execReturn(ReturnStmt &s);
    void execPrint(PrintStmt &s);
    void execInput(InputStmt &s);
    void execImport(ImportStmt &s);
    void execExprStmt(ExprStmt &s);
```

**Statement Execution Analysis:**

**Declaration Statements:**
- **`execVarDecl()`**: Variable declarations with type hints and initializers
- **`execFunctionDecl()`**: Function declarations with closure capture
- **`execClassDecl()`**: Class declarations with methods and inheritance

**Control Flow Statements:**
- **`execIf()`**: Conditional execution with if/elif/else branches
- **`execWhile()`**: Loop execution with condition checking
- **`execFor()`**: Iteration over iterables with variable binding

**Other Statements:**
- **`execReturn()`**: Function return with value propagation
- **`execPrint()`**: Output statements with formatting
- **`execInput()`**: Input statements with prompt and variable assignment
- **`execImport()`**: Module import statements
- **`execExprStmt()`**: Expression statements (function calls, assignments)

**Expression Evaluation Methods (Lines 34-45):**
```cpp
    // Expression evaluators
    QuantumValue evalBinary(BinaryExpr &e);
    QuantumValue evalUnary(UnaryExpr &e);
    QuantumValue evalAssign(AssignExpr &e);
    QuantumValue evalCall(CallExpr &e);
    QuantumValue evalIndex(IndexExpr &e);
    QuantumValue evalMember(MemberExpr &e);
    QuantumValue evalArray(ArrayLiteral &e);
    QuantumValue evalDict(DictLiteral &e);
    QuantumValue evalLambda(LambdaExpr &e);
    QuantumValue evalListComp(ListComp &e);
    QuantumValue evalIdentifier(Identifier &e);
```

**Expression Evaluation Analysis:**

**Binary Operations:**
- **`evalBinary()`**: Binary expressions with type-based dispatch
- **Operators**: Arithmetic, comparison, logical, bitwise operations
- **Type Coercion**: Handles mixed-type operations

**Unary Operations:**
- **`evalUnary()`**: Unary expressions (+, -, !, ~)
- **Type-specific**: Different behavior for different operand types

**Assignment and Access:**
- **`evalAssign()`**: Assignment expressions with compound operators
- **`evalIndex()`**: Array/dictionary indexing and slicing
- **`evalMember()`**: Object member access (dot notation)

**Literals and Creation:**
- **`evalArray()`**: Array literal creation
- **`evalDict()`**: Dictionary literal creation
- **`evalLambda()`**: Lambda function creation with closure capture

**Special Expressions:**
- **`evalListComp()`**: List comprehension evaluation
- **`evalIdentifier()`**: Variable resolution through environment chain

**Function Call Methods (Lines 47-49):**
```cpp
    QuantumValue callFunction(std::shared_ptr<QuantumFunction> fn, std::vector<QuantumValue> args);
    QuantumValue callNative(std::shared_ptr<QuantumNative> fn, std::vector<QuantumValue> args);
    QuantumValue callInstanceMethod(std::shared_ptr<QuantumInstance> inst, std::shared_ptr<QuantumFunction> fn, std::vector<QuantumValue> args);
```

**Function Call Analysis:**

**User Functions:**
- **`callFunction()`**: Calls user-defined Quantum Language functions
- **Closure Handling**: Manages lexical environment during execution
- **Parameter Binding**: Matches arguments to parameters
- **Return Value Handling**: Captures and propagates return values

**Native Functions:**
- **`callNative()`**: Calls C++ implemented native functions
- **Type Conversion**: Handles argument type checking and conversion
- **Error Handling**: Converts C++ exceptions to Quantum Language errors

**Instance Methods:**
- **`callInstanceMethod()`**: Calls methods on object instances
- **Self Binding**: Binds `this`/`self` to instance
- **Inheritance**: Handles method resolution through inheritance chain

**Method Dispatch System (Lines 51-55):**
```cpp
    // Built-in method dispatch
    QuantumValue callMethod(QuantumValue &obj, const std::string &method, std::vector<QuantumValue> args);
    QuantumValue callArrayMethod(std::shared_ptr<Array> arr, const std::string &method, std::vector<QuantumValue> args);
    QuantumValue callStringMethod(const std::string &str, const std::string &method, std::vector<QuantumValue> args);
    QuantumValue callDictMethod(std::shared_ptr<Dict> dict, const std::string &method, std::vector<QuantumValue> args);
```

**Method Dispatch Analysis:**

**General Dispatch:**
- **`callMethod()`**: Main method dispatcher based on object type
- **Type Detection**: Determines object type and routes to appropriate handler
- **Error Handling**: Provides clear error messages for invalid method calls

**Type-specific Methods:**
- **`callArrayMethod()`**: Array methods (push, pop, sort, etc.)
- **`callStringMethod()`**: String methods (length, substring, etc.)
- **`callDictMethod()`**: Dictionary methods (keys, values, etc.)

**Assignment Helper (Line 57):**
```cpp
    void setLValue(ASTNode &target, QuantumValue val, const std::string &op);
```

**L-value Assignment:**
- **Purpose**: Handles assignment to complex l-values (arrays, objects)
- **Parameters**: 
  - `target`: AST node representing assignment target
  - `val`: Value to assign
  - `op`: Assignment operator (=, +=, -=, etc.)
- **Complex Targets**: Handles `obj.prop`, `arr[index]`, etc.

## Design Patterns and Architecture

### Visitor Pattern
```cpp
void execute(ASTNode &node) {
    std::visit([this](auto &stmt) {
        using T = std::decay_t<decltype(stmt)>;
        if constexpr (std::is_same_v<T, VarDecl>) execVarDecl(stmt);
        // ... dispatch to appropriate executor
    }, node.node);
}
```

**Benefits:**
- **Type Safety**: Compile-time dispatch to correct handler
- **Extensibility**: Easy to add new node types
- **Performance**: No virtual function overhead
- **Maintainability**: Clear separation of concerns

### Environment Chain Pattern
```
Global Environment
├── Function Closure
│   └── Local Scope
└── Another Function
    └── Block Scope
```

**Features:**
- **Lexical Scoping**: Variables follow static scope rules
- **Closures**: Functions capture their defining environment
- **Memory Management**: Shared pointers prevent dangling references

### Strategy Pattern for Methods
```cpp
QuantumValue callMethod(QuantumValue &obj, const std::string &method, std::vector<QuantumValue> args) {
    if (obj.isString()) return callStringMethod(...);
    if (obj.isArray()) return callArrayMethod(...);
    if (obj.isDict()) return callDictMethod(...);
    if (obj.isInstance()) return callInstanceMethod(...);
}
```

**Benefits:**
- **Type-based Dispatch**: Different strategies for different types
- **Extensibility**: Easy to add new types with methods
- **Encapsulation**: Each type handles its own methods

## Integration with Compiler Pipeline

### AST Execution
```cpp
// In main.cpp
Interpreter interp;
interp.execute(*ast);  // Execute the parsed AST
```

**Integration Features:**
- **Tree Input**: Takes AST from parser as input
- **Environment Setup**: Initializes global environment
- **Program Execution**: Executes entire program or individual statements

### Value System Integration
```cpp
QuantumValue result = evaluate(*exprNode);
env->define("x", result);
```

**Value Features:**
- **Dynamic Types**: All values use QuantumValue system
- **Type Safety**: Runtime type checking with clear errors
- **Memory Management**: Smart pointers handle cleanup

### Function and Method Calls
```cpp
// Function closure capture
auto fn = std::make_shared<QuantumFunction>();
fn->closure = currentEnv;

// Method resolution and dispatch
auto method = instance->getField("methodName");
callInstanceMethod(instance, method, args);
```

**OOP Integration:**
- **Closures**: Functions capture lexical environment
- **Method Resolution**: Instance and class method lookup
- **Inheritance**: Base class method access through environment chain

## Performance Considerations

### Efficient AST Traversal
```cpp
void execute(ASTNode &node) {
    std::visit([this](auto &stmt) {
        // Direct dispatch without virtual calls
    }, node.node);
}
```

**Optimizations:**
- **No Virtual Calls**: Uses std::visit for compile-time dispatch
- **Inline Potential**: Simple methods can be inlined
- **Cache Friendly**: Sequential AST traversal

### Memory Management
```cpp
std::shared_ptr<Environment> env;
std::shared_ptr<QuantumFunction> fn;
```

**Memory Features:**
- **Smart Pointers**: Automatic memory management
- **Reference Counting**: Shared ownership with automatic cleanup
- **RAII**: Exception-safe resource management

### Environment Lookup Optimization
```cpp
QuantumValue get(const std::string& name) const {
    auto it = vars.find(name);
    if (it != vars.end()) return it->second;
    if (parent) return parent->get(name);
    throw NameError("Undefined variable: '" + name + "'");
}
```

**Optimization Features:**
- **Hash Table Lookup**: O(1) average variable access
- **Short-circuit**: Returns immediately when found
- **Cache Locality**: Good memory access patterns

## Error Handling Strategy

### Exception-based Control Flow
```cpp
try {
    execute(*body);
} catch (const BreakSignal &) {
    break;
} catch (const ContinueSignal &) {
    continue;
} catch (const ReturnSignal &ret) {
    return ret.value;
}
```

**Control Flow Benefits:**
- **Clean Implementation**: No flag variables needed
- **Nested Structures**: Proper handling of nested loops
- **Efficient**: Zero-cost when no exceptions thrown

### Type Safety and Validation
```cpp
if (!left.isNumber() || !right.isNumber())
    throw TypeError("Operands must be numbers for " + op);
```

**Safety Features:**
- **Runtime Type Checking**: Prevents type-related crashes
- **Clear Error Messages**: Helpful debugging information
- **Context Preservation**: Error messages include operation context

## Native Function Integration

### Registration System
```cpp
void registerNatives() {
    env->define("print", QuantumValue(std::make_shared<QuantumNative>(QuantumNative{
        "print", [this](std::vector<QuantumValue> args) -> QuantumValue {
            // Native implementation
        }
    })));
}
```

**Integration Features:**
- **C++ Bridge**: Connects Quantum Language to C++ functionality
- **Type Safety**: Automatic argument type checking
- **Error Handling**: C++ exceptions converted to Quantum Language errors

### Standard Library Support
- **Mathematical Functions**: sin, cos, sqrt, pow, etc.
- **String Operations**: length, substring, split, join
- **Array Methods**: push, pop, sort, filter, map
- **File I/O**: open, read, write, close
- **Cybersecurity**: hash, encrypt, decrypt, scan

## Why This Design Works

### Comprehensive Runtime Support
- **Complete Language Features**: All language constructs fully implemented
- **Rich Standard Library**: Extensive built-in functions for common tasks
- **Object-Oriented Programming**: Full class and instance support
- **Functional Programming**: First-class functions with closures

### Performance and Safety
- **Modern C++ Features**: Variant-based types, smart pointers, move semantics
- **Type Safety**: Runtime type checking with clear error messages
- **Memory Management**: Automatic cleanup through smart pointers
- **Efficient Execution**: Optimized AST traversal and environment lookup

### Extensibility and Maintainability
- **Clean Architecture**: Clear separation between parsing and execution
- **Modular Design**: Each component has single responsibility
- **Visitor Pattern**: Easy to add new AST node types
- **Native Function Bridge**: Straightforward addition of new built-in functions

The interpreter interface provides a robust, comprehensive execution environment for Quantum Language, combining the flexibility of dynamic scripting with the performance and safety of modern C++ implementation.
