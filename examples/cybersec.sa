# cybersec.sa — Cybersecurity Tools in Quantum
# Run: quantum cybersec.sa

print("=== Quantum CyberSec Toolkit ===\n")

# ── XOR Cipher (common in reverse engineering & CTFs) ────────────────────
fn xor_encrypt(plaintext, key) {
    let result = ""
    let i = 0
    while i < len(plaintext) {
        let p = ord(plaintext[i])
        let k = ord(key[i % len(key)])
        result += chr(p ^ k)
        i += 1
    }
    return result
}

let message  = "TOP SECRET"
let key      = "QUANTUM"
let encrypted = xor_encrypt(message, key)
let decrypted = xor_encrypt(encrypted, key)  # XOR is its own inverse

print("[XOR Cipher]")
print("  Original:  ", message)
print("  Encrypted: ", to_hex(encrypted))
print("  Decrypted: ", decrypted)

# ── Caesar Cipher ────────────────────────────────────────────────────────
fn caesar_cipher(text, shift) {
    let result = ""
    for ch in text {
        let code = ord(ch)
        if code >= 65 and code <= 90 {
            result += chr((code - 65 + shift) % 26 + 65)
        } elif code >= 97 and code <= 122 {
            result += chr((code - 97 + shift) % 26 + 97)
        } else {
            result += ch
        }
    }
    return result
}

print("\n[Caesar Cipher]")
let secret = "Hello Quantum"
let encoded = caesar_cipher(secret, 13)
print("  Original:  ", secret)
print("  ROT13:     ", encoded)
print("  Decoded:   ", rot13(encoded))

# ── Hex encoding/decoding ─────────────────────────────────────────────────
print("\n[Hex Encoding]")
let data = "Quantum is secure"
let hexed = to_hex(data)
let unhexed = from_hex(hexed)
print("  Data:      ", data)
print("  Hex:       ", hexed)
print("  Decoded:   ", unhexed)

# ── Base64 Encoding ──────────────────────────────────────────────────────
print("\n[Base64 Encoding]")
let secret_data = "admin:password123"
let b64 = base64_encode(secret_data)
print("  Original:  ", secret_data)
print("  Base64:    ", b64)

# ── Brute-Force Password Cracker (demo) ──────────────────────────────────
print("\n[Brute-Force Demo]")

fn simple_hash(s) {
    # Not a real hash - just a demo
    let h = 5381
    for ch in s {
        h = ((h << 5) + h) + ord(ch)
        h = h & 0xFFFFFF  # Keep it bounded
    }
    return h
}

let target_pass = "abc"
let target_hash = simple_hash(target_pass)
print("  Target hash:", target_hash)

let charset = "abcdefghijklmnopqrstuvwxyz"
let found = false

for a in charset.split("") {
    for b in charset.split("") {
        for c in charset.split("") {
            let attempt = a + b + c
            if simple_hash(attempt) == target_hash {
                print("  ✓ Password cracked:", attempt)
                found = true
                break
            }
        }
        if found { break }
    }
    if found { break }
}

# ── Pattern Analysis ──────────────────────────────────────────────────────
print("\n[Pattern Analysis - Frequency]")

fn char_frequency(text) {
    let freq = {}
    for ch in text.lower() {
        if ch != " " {
            let count = freq.get(ch, 0)
            freq.set(ch, count + 1)
        }
    }
    return freq
}

let sample = "The quick brown fox jumps over the lazy dog"
let freq = char_frequency(sample)
print("  Text:", sample)
print("  Unique chars:", len(freq))

# ── IP/Port Scanner Simulator ─────────────────────────────────────────────
print("\n[Port Scanner Simulator]")

fn is_common_port(port) {
    let common = [21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 3306, 3389, 8080, 8443]
    return common.contains(port)
}

fn get_service(port) {
    let services = {
        "21": "FTP",  "22": "SSH",   "23": "Telnet", "25": "SMTP",
        "53": "DNS",  "80": "HTTP",  "110": "POP3",  "143": "IMAP",
        "443": "HTTPS","445": "SMB", "3306": "MySQL","3389": "RDP",
        "8080": "HTTP-Alt", "8443": "HTTPS-Alt"
    }
    return services.get(str(port), "Unknown")
}

let scan_ports = [22, 80, 443, 8080, 3306, 9999, 12345]
print("  Simulated scan of 192.168.1.1:")

for port in scan_ports {
    let status = "FILTERED"
    if is_common_port(port) { status = "OPEN" }
    let service = get_service(port)
    print("  Port", port, "->", status, "|", service)
}

# ── Password Strength Checker ─────────────────────────────────────────────
print("\n[Password Strength Checker]")

fn check_password_strength(pw) {
    let score = 0
    let feedback = []

    if len(pw) >= 8 { score += 1 } else { feedback.push("Too short (< 8 chars)") }
    if len(pw) >= 12 { score += 1 }

    let has_upper = false
    let has_lower = false
    let has_digit = false
    let has_special = false

    for ch in pw {
        let c = ord(ch)
        if c >= 65 and c <= 90  { has_upper = true }
        if c >= 97 and c <= 122 { has_lower = true }
        if c >= 48 and c <= 57  { has_digit = true }
        if (c < 48 or (c > 57 and c < 65) or (c > 90 and c < 97) or c > 122) {
            has_special = true
        }
    }

    if has_upper   { score += 1 } else { feedback.push("Add uppercase letters") }
    if has_lower   { score += 1 } else { feedback.push("Add lowercase letters") }
    if has_digit   { score += 1 } else { feedback.push("Add digits") }
    if has_special { score += 2 } else { feedback.push("Add special characters (!@#$...)") }

    let strength = "WEAK"
    if score >= 5 { strength = "MEDIUM" }
    if score >= 7 { strength = "STRONG" }

    return {"score": score, "strength": strength, "feedback": feedback}
}

let passwords = ["abc", "Password1", "Qu@ntum$ecur1ty!", "hello123"]
for pw in passwords {
    let result = check_password_strength(pw)
    print("  '" + pw + "' -> " + result["strength"] + " (score: " + str(result["score"]) + ")")
    let fb = result["feedback"]
    if len(fb) > 0 {
        for tip in fb { print("    ↳", tip) }
    }
}

print("\n[Done] Quantum CyberSec Demo Complete")
