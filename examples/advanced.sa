# advanced.sa — Advanced Quantum Features
# Run: quantum advanced.sa

# ── Recursive Data Structures ─────────────────────────────────────────────
print("=== Linked List via Dicts ===")

fn make_node(val, next) {
    return {"val": val, "next": next}
}

fn list_to_str(node) {
    if node == nil { return "nil" }
    return str(node["val"]) + " -> " + list_to_str(node["next"])
}

let lst = make_node(1, make_node(2, make_node(3, nil)))
print(list_to_str(lst))

# ── Higher Order Functions ────────────────────────────────────────────────
print("\n=== Higher Order Functions ===")

fn compose(f, g) {
    return fn(x) { return f(g(x)) }
}


print("double(inc(5)) =", doubleAfterInc(5))

fn reduce(arr, fn_, init) {
    let acc = init
    for item in arr {
        acc = fn_(acc, item)
    }
    return acc
}

let nums = [1, 2, 3, 4, 5]
let sum  = reduce(nums, fn(a, b) { return a + b }, 0)
let prod = reduce(nums, fn(a, b) { return a * b }, 1)
print("Sum:", sum, "| Product:", prod)

# ── Fibonacci with memoization ────────────────────────────────────────────
print("\n=== Memoized Fibonacci ===")
let memo = {}

fn fib(n) {
    let key = str(n)
    if memo.has(key) { return memo.get(key) }
    if n <= 1 { return n }
    let result = fib(n - 1) + fib(n - 2)
    memo.set(key, result)
    return result
}

for i in range(0, 15) {
    print("fib(" + str(i) + ") =", fib(i))
}

# ── String interpolation helper ───────────────────────────────────────────
print("\n=== String Operations ===")

fn repeat_str(s, n) {
    let res = ""
    for _ in range(n) { res += s }
    return res
}

print(repeat_str("=-", 20))

fn center(s, width) {
    let pad = width - len(s)
    let left = pad / 2
    let right = pad - left
    return repeat_str(" ", floor(left)) + s + repeat_str(" ", floor(right))
}

let banner_width = 40
print(repeat_str("=", banner_width))
print(center("QUANTUM LANGUAGE", banner_width))
print(center("v1.0.0", banner_width))
print(repeat_str("=", banner_width))

# ── Sorting algorithms ────────────────────────────────────────────────────
print("\n=== Bubble Sort ===")

fn bubble_sort(arr) {
    let n = len(arr)
    let i = 0
    while i < n {
        let j = 0
        while j < n - i - 1 {
            if arr[j] > arr[j+1] {
                let tmp = arr[j]
                arr[j] = arr[j+1]
                arr[j+1] = tmp
            }
            j += 1
        }
        i += 1
    }
    return arr
}

let unsorted = [64, 34, 25, 12, 22, 11, 90]
print("Before:", unsorted)
bubble_sort(unsorted)
print("After: ", unsorted)

# ── Stack implementation ───────────────────────────────────────────────────
print("\n=== Stack ===")

fn make_stack() {
    return {"items": [], "size": 0}
}

fn stack_push(s, val) {
    s["items"].push(val)
    s["size"] += 1
}

fn stack_pop(s) {
    if s["size"] == 0 { return nil }
    s["size"] -= 1
    return s["items"].pop()
}

fn stack_peek(s) {
    if s["size"] == 0 { return nil }
    return s["items"][s["size"] - 1]
}

let stack = make_stack()
stack_push(stack, 10)
stack_push(stack, 20)
stack_push(stack, 30)
print("Stack:", stack["items"])
print("Peek:", stack_peek(stack))
print("Pop:", stack_pop(stack))
print("Pop:", stack_pop(stack))
print("Stack:", stack["items"])

# ── Simple State Machine ──────────────────────────────────────────────────
print("\n=== Traffic Light State Machine ===")

let STATES = ["RED", "GREEN", "YELLOW"]
let state_idx = 0

fn next_state() {
    state_idx = (state_idx + 1) % len(STATES)
    return STATES[state_idx]
}

fn current_state() {
    return STATES[state_idx]
}

print("Current:", current_state())
for _ in range(6) {
    print("→", next_state())
}
