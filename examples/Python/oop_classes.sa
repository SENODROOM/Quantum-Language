# ════════════════════════════════════════════════════════════════════
#  Quantum Language — Object-Oriented Programming Demo
# ════════════════════════════════════════════════════════════════════

print("═══ 1. Basic Class with Constructor ═══")

class Animal:
    fn init(name, sound):
        self.name = name
        self.sound = sound

    fn speak():
        return self.name + " says " + self.sound

    fn __str__():
        return "Animal(" + self.name + ")"

cat = Animal("Whiskers", "Meow")
print(cat.speak())
print("toString:", cat)

print("")
print("═══ 2. Inheritance & super() ═══")

class Dog extends Animal:
    fn init(name, breed):
        super(name, "Woof")
        self.breed = breed

    fn fetch(item):
        return self.name + " the " + self.breed + " fetches the " + item

    fn __str__():
        return "Dog(" + self.name + ", " + self.breed + ")"

dog = Dog("Rex", "German Shepherd")
print(dog.speak())
print(dog.fetch("ball"))
print("toString:", dog)

print("")
print("═══ 3. Method Overriding & super.method() ═══")

class Cat extends Animal:
    fn init(name, indoor):
        super(name, "Meow")
        self.indoor = indoor

    fn speak():
        let base_speak = super.speak()
        if self.indoor:
            return base_speak + " (from inside)"
        return base_speak

kitty = Cat("Luna", true)
print(kitty.speak())

print("")
print("═══ 4. isinstance() ═══")

print("dog isinstance Animal:", isinstance(dog, Animal))
print("dog isinstance Dog:", isinstance(dog, Dog))
print("cat isinstance Dog:", isinstance(cat, Dog))
print("kitty isinstance Animal:", isinstance(kitty, Animal))

print("")
print("═══ 5. Static Methods ═══")

class MathUtils:
    static fn add(a, b):
        return a + b

    static fn multiply(a, b):
        return a * b

    static fn square(x):
        return x * x

print("MathUtils.add(3, 4):", MathUtils.add(3, 4))
print("MathUtils.multiply(5, 6):", MathUtils.multiply(5, 6))
print("MathUtils.square(8):", MathUtils.square(8))

print("")
print("═══ 6. Multi-level Inheritance ═══")

class Vehicle:
    fn init(make, year):
        self.make = make
        self.year = year

    fn info():
        return self.make + " (" + str(self.year) + ")"

class Car extends Vehicle:
    fn init(make, year, doors):
        super(make, year)
        self.doors = doors

    fn info():
        return super.info() + " - " + str(self.doors) + " doors"

class ElectricCar extends Car:
    fn init(make, year, doors, range_km):
        super(make, year, doors)
        self.range_km = range_km

    fn info():
        return super.info() + " [EV, " + str(self.range_km) + "km range]"

tesla = ElectricCar("Tesla Model 3", 2024, 4, 580)
print(tesla.info())
print("isinstance Vehicle:", isinstance(tesla, Vehicle))
print("isinstance Car:", isinstance(tesla, Car))
print("isinstance ElectricCar:", isinstance(tesla, ElectricCar))

print("")
print("═══ 7. JavaScript-style Class (brace syntax) ═══")

class Counter {
    constructor(start) {
        this.count = start;
    }

    increment() {
        this.count = this.count + 1;
    }

    decrement() {
        this.count = this.count - 1;
    }

    toString() {
        return "Counter(" + str(this.count) + ")";
    }
}

let c = new Counter(10)
c.increment()
c.increment()
c.increment()
c.decrement()
print("Counter value:", c.count)
print("Counter string:", c)

print("")
print("═══ 8. classname() builtin ═══")
print("classname(dog):", classname(dog))
print("classname(tesla):", classname(tesla))
print("classname(c):", classname(c))

print("")
print("═══ 9. Instance Field Assignment ═══")
class Point:
    fn init(x, y):
        self.x = x
        self.y = y

    fn __str__():
        return "(" + str(self.x) + ", " + str(self.y) + ")"

    fn distance_to(other):
        let dx = self.x - other.x
        let dy = self.y - other.y
        return (dx * dx + dy * dy) ** 0.5

let p1 = Point(3, 4)
let p2 = Point(0, 0)
print("p1:", p1)
print("p2:", p2)
print("Distance:", p1.distance_to(p2))

# Modify fields
p1.x = 6
p1.y = 8
print("p1 after modification:", p1)
print("Distance after mod:", p1.distance_to(p2))

print("")
print("═══ All OOP tests passed! ═══")
